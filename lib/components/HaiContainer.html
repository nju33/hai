<div ref:cover class="{{className.cover}} {{visibility === 'visible' ? className.fadeIn : ''}}"
     on:click="close()">
  <svg xmlns="http://www.w3.org/2000/svg">
    <symbol id="close" viewBox="0 0 10 10">
    </symbol>
  </svg>
  <div ref:box class="{{className.box}} {{visibility === 'visible' ? className.fadeIn : ''}}"
    　　on:click="cancelEvent(event)"
  ></div>
</div>

<script>
  import className from '../class-name.json';
  import store from '../store';
  import {resetTalks} from '../action';
  import {requestAnimationFrame} from '../helpers';

  const BITE = 20;

  export default {
    data() {
      return {
        visibility: 'hidden',
        className
      }
    },

    onrender() {
      this.observe('boundingClientRect', () => {
        if (!this.get('boundingClientRect')) {
          return;
        }

        const {boundingClientRect} = this.get();
        this.setPosition(boundingClientRect);
      });
    },

    methods: {
      cancelEvent(e) {
        e.stopPropagation();
      },
      close() {
        store.dispatch(resetTalks());
      },
      appendComponent(elem) {
        this.refs.box.appendChild(elem);
      },
      isVisible() {
        return this.get('visibility') === 'visible';
      },
      toBlockElements() {
        this.refs.cover.style.display = 'block';
        this.refs.box.style.display = 'block';
      },
      toNoneElements() {
        this.refs.cover.style.display = 'none';
        this.refs.box.style.display = 'none';
      },
      setPosition() {
        const {top, left} = this.get('boundingClientRect');
        const boxHeight = this.refs.box.clientHeight;
        const boxWidth = this.refs.box.clientWidth;
        const requiredVirticalArea = top + boxHeight;
        const requiredHorizontalArea = left + boxWidth;
        let virticalOverAmount = 0;
        let horizontalOverAmount = 0;

        if (requiredVirticalArea > window.innerHeight) {
          virticalOverAmount = requiredVirticalArea - window.innerHeight;
        }

        if (requiredHorizontalArea > window.innerWidth) {
          horizontalOverAmount = requiredHorizontalArea - window.innerWidth;
        }

        if (window.innerHeight - requiredVirticalArea > BITE) {
          this.refs.box.style.top = `${top - virticalOverAmount - BITE}px`;
        } else {
          this.refs.box.style.top = `${top - virticalOverAmount}px`;
        }

        if (window.innerWidth - requiredHorizontalArea > BITE) {
          this.refs.box.style.left = `${left - horizontalOverAmount - BITE}px`;
        } else {
          this.refs.box.style.left = `${left - horizontalOverAmount}px`;
        }
      },
      fadeIn() {
        this.refs.cover.classList.add(className.fadeIn);
        this.refs.box.classList.add(className.fadeIn);
      },
      fadeOut() {
        this.refs.cover.classList.remove(className.fadeIn);
        this.refs.box.classList.remove(className.fadeIn);
      },
      show() {
        const {helpers} = this.get();
        const {waitDuringDuration} = helpers;

        return new Promise(resolve => {
          this.toBlockElements();
          this.setPosition();

          requestAnimationFrame(() => {
            console.info('container:fadeIn');
            this.fadeIn();
            waitDuringDuration().then(() => {
              this.set({visibility: 'visible'});
              resolve();
            });
          });
        });
      },
      hide() {
        const {helpers} = this.get();
        const {waitDuringDuration} = helpers;

        return new Promise(resolve => {
          console.info('container:fadeOut');
          this.fadeOut();
          waitDuringDuration().then(() => {
            this.toNoneElements();
            this.set({visibility: 'hidden'});
            resolve();
          });
        });
      }
    }
  }
</script>
